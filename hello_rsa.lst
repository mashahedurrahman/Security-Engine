   1              		.file	"hello_rsa.c"
   2              		.option nopic
   3              	# GNU C99 (GCC) version 7.2.0 (riscv64-unknown-elf)
   4              	#	compiled by GNU C version 7.5.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   5              	# warning: GMP header version 6.2.0 differs from library version 6.3.0.
   6              	# warning: MPFR header version 4.0.2 differs from library version 4.2.1.
   7              	# warning: MPC header version 1.1.0 differs from library version 1.0.1.
   8              	# GGC heuristics: --param ggc-min-expand=30 --param ggc-min-heapsize=4096
   9              	# options passed: 
  10              	# -iprefix /ecel/UFAD/mrahman1/cva6_for_se/cva6_09222023/riscv_install/bin/../lib/gcc/riscv64-unkno
  11              	# -isysroot /ecel/UFAD/mrahman1/cva6_for_se/cva6_09222023/riscv_install/bin/../riscv64-unknown-elf
  12              	# -D PREALLOCATE=1 hello_rsa.c -mcmodel=medany -march=rv64imafdc
  13              	# -mabi=lp64d -auxbase-strip hello_rsa.s -g -O2 -std=gnu99 -fverbose-asm
  14              	# -ffast-math -fno-common -fno-builtin-printf
  15              	# -fno-tree-loop-distribute-patterns
  16              	# options enabled:  -faggressive-loop-optimizations -falign-functions
  17              	# -falign-jumps -falign-labels -falign-loops -fassociative-math
  18              	# -fauto-inc-dec -fbranch-count-reg -fcaller-saves
  19              	# -fchkp-check-incomplete-type -fchkp-check-read -fchkp-check-write
  20              	# -fchkp-instrument-calls -fchkp-narrow-bounds -fchkp-optimize
  21              	# -fchkp-store-bounds -fchkp-use-static-bounds
  22              	# -fchkp-use-static-const-bounds -fchkp-use-wrappers -fcode-hoisting
  23              	# -fcombine-stack-adjustments -fcompare-elim -fcprop-registers
  24              	# -fcrossjumping -fcse-follow-jumps -fcx-limited-range -fdefer-pop
  25              	# -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
  26              	# -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-types
  27              	# -fexpensive-optimizations -ffinite-math-only -fforward-propagate
  28              	# -ffp-int-builtin-inexact -ffunction-cse -fgcse -fgcse-lm -fgnu-runtime
  29              	# -fgnu-unique -fguess-branch-probability -fhoist-adjacent-loads -fident
  30              	# -fif-conversion -fif-conversion2 -findirect-inlining -finline
  31              	# -finline-atomics -finline-functions-called-once -finline-small-functions
  32              	# -fipa-bit-cp -fipa-cp -fipa-icf -fipa-icf-functions -fipa-icf-variables
  33              	# -fipa-profile -fipa-pure-const -fipa-ra -fipa-reference -fipa-sra
  34              	# -fipa-vrp -fira-hoist-pressure -fira-share-save-slots
  35              	# -fira-share-spill-slots -fisolate-erroneous-paths-dereference -fivopts
  36              	# -fkeep-static-consts -fleading-underscore -flifetime-dse -flra-remat
  37              	# -flto-odr-type-merging -fmerge-constants -fmerge-debug-strings
  38              	# -fmove-loop-invariants -fomit-frame-pointer -foptimize-sibling-calls
  39              	# -foptimize-strlen -fpartial-inlining -fpeephole -fpeephole2 -fplt
  40              	# -fprefetch-loop-arrays -freciprocal-math -free -freg-struct-return
  41              	# -freorder-blocks -freorder-functions -frerun-cse-after-loop
  42              	# -fsched-critical-path-heuristic -fsched-dep-count-heuristic
  43              	# -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
  44              	# -fsched-rank-heuristic -fsched-spec -fsched-spec-insn-heuristic
  45              	# -fsched-stalled-insns-dep -fschedule-fusion -fschedule-insns
  46              	# -fschedule-insns2 -fsection-anchors -fsemantic-interposition
  47              	# -fshow-column -fshrink-wrap -fshrink-wrap-separate
  48              	# -fsplit-ivs-in-unroller -fsplit-wide-types -fssa-backprop -fssa-phiopt
  49              	# -fstdarg-opt -fstore-merging -fstrict-aliasing -fstrict-overflow
  50              	# -fstrict-volatile-bitfields -fsync-libcalls -fthread-jumps
  51              	# -ftoplevel-reorder -ftree-bit-ccp -ftree-builtin-call-dce -ftree-ccp
  52              	# -ftree-ch -ftree-coalesce-vars -ftree-copy-prop -ftree-dce
  53              	# -ftree-dominator-opts -ftree-dse -ftree-forwprop -ftree-fre
  54              	# -ftree-loop-if-convert -ftree-loop-im -ftree-loop-ivcanon
  55              	# -ftree-loop-optimize -ftree-parallelize-loops= -ftree-phiprop -ftree-pre
  56              	# -ftree-pta -ftree-reassoc -ftree-scev-cprop -ftree-sink -ftree-slsr
  57              	# -ftree-sra -ftree-switch-conversion -ftree-tail-merge -ftree-ter
  58              	# -ftree-vrp -funit-at-a-time -funsafe-math-optimizations -fvar-tracking
  59              	# -fvar-tracking-assignments -fverbose-asm -fzero-initialized-in-bss -mdiv
  60              	# -mfdiv -mplt -mstrict-align
  61              	
  62              		.text
  63              	.Ltext0:
  64              		.cfi_sections	.debug_frame
  65              		.align	1
  66              		.globl	custom_memcpy
  68              	custom_memcpy:
  69              	.LFB0:
  70              		.file 1 "hello_rsa.c"
   1:hello_rsa.c   **** 
   2:hello_rsa.c   **** void custom_memcpy(volatile void *dest, volatile void *src, int n) {
  71              		.loc 1 2 0
  72              		.cfi_startproc
  73              	.LVL0:
  74              	# hello_rsa.c:7:    for (i=0; i<n; i++)
   3:hello_rsa.c   ****    int i;
   4:hello_rsa.c   ****    //cast src and dest to char*
   5:hello_rsa.c   ****    char *src_char = (char *)src;
   6:hello_rsa.c   ****    char *dest_char = (char *)dest;
   7:hello_rsa.c   ****    for (i=0; i<n; i++)
  75              		.loc 1 7 0
  76              		blez	a2,.L1	#, n,
  77              		addiw	a5,a2,-1	#, tmp114, n
  78              		slli	a5,a5,32	#, tmp115, tmp114
  79              		srli	a5,a5,32	#, tmp115, tmp115
  80              		addi	a5,a5,1	#, tmp116, tmp115
  81              		add	a5,a1,a5	# tmp116, _27, ivtmp.8
  82              	.LVL1:
  83              	.L3:
  84              	# hello_rsa.c:8:       dest_char[i] = src_char[i]; //copy contents byte by byte
   8:hello_rsa.c   ****       dest_char[i] = src_char[i]; //copy contents byte by byte
  85              		.loc 1 8 0 discriminator 3
  86              		lbu	a4,0(a1)	# _4, MEM[base: _13, offset: 0B]
  87              		addi	a0,a0,1	#, ivtmp.9, ivtmp.9
  88              		addi	a1,a1,1	#, ivtmp.8, ivtmp.8
  89              	.LVL2:
  90              		sb	a4,-1(a0)	# _4, MEM[base: _21, offset: 0B]
  91              	# hello_rsa.c:7:    for (i=0; i<n; i++)
   7:hello_rsa.c   ****       dest_char[i] = src_char[i]; //copy contents byte by byte
  92              		.loc 1 7 0 discriminator 3
  93              		bne	a1,a5,.L3	#, ivtmp.8, _27,
  94              	.L1:
  95              	# hello_rsa.c:9: }
   9:hello_rsa.c   **** }
  96              		.loc 1 9 0
  97 ???? C3       		ret
  98              		.cfi_endproc
  99              	.LFE0:
 101              		.align	1
 102              		.globl	custom_memcpy_2
 104              	custom_memcpy_2:
 105              	.LFB4:
 106              		.cfi_startproc
 107              		tail	custom_memcpy	#
 108              		.cfi_endproc
 109              	.LFE4:
 111              		.section	.text.startup,"ax",@progbits
 112              		.align	1
 113              		.globl	main
 115              	main:
 116              	.LFB2:
  10:hello_rsa.c   **** 
  11:hello_rsa.c   **** void custom_memcpy_2(volatile void *dest, volatile void *src, int n) {
  12:hello_rsa.c   ****    int j;
  13:hello_rsa.c   ****    //cast src and dest to char*
  14:hello_rsa.c   ****    char *src_char = (char *)src;
  15:hello_rsa.c   ****    char *dest_char = (char *)dest;
  16:hello_rsa.c   ****    for (j=0; j<n; j++)
  17:hello_rsa.c   ****       dest_char[j] = src_char[j]; //copy contents byte by byte
  18:hello_rsa.c   **** }
  19:hello_rsa.c   **** 
  20:hello_rsa.c   **** 
  21:hello_rsa.c   **** int main(int argc, char const *argv[]) {
 117              		.loc 1 21 0
 118              		.cfi_startproc
 119              	.LVL3:
 120              	# hello_rsa.c:30:     *(addr_rsa+96) = 0;
  22:hello_rsa.c   ****     volatile unsigned long long int *addr_rsa = (volatile unsigned long long int*) 0x50000000;
  23:hello_rsa.c   ****     volatile unsigned long long int *addr_dram = (volatile unsigned long long int*) 0x90000000;
  24:hello_rsa.c   ****     unsigned long long int data;
  25:hello_rsa.c   **** 
  26:hello_rsa.c   ****     // Exercise RSA
  27:hello_rsa.c   **** 
  28:hello_rsa.c   ****     // Test 1
  29:hello_rsa.c   ****     // go = 0
  30:hello_rsa.c   ****     *(addr_rsa+96) = 0;
 121              		.loc 1 30 0
 122              		li	a5,1342177280	# tmp141,
 123              		sd	zero,768(a5)	#, MEM[(volatile long long unsigned int *)1342178048B]
 124              	.LVL4:
 125              	.LBB12:
 126              	# hello_rsa.c:33:     for (int i = 31; i >= 1; i--) {
  31:hello_rsa.c   ****     
  32:hello_rsa.c   ****     // message = 8
  33:hello_rsa.c   ****     for (int i = 31; i >= 1; i--) {
 127              		.loc 1 33 0
 128              		li	a4,1342177280	# tmp142,
 129              	.LBE12:
 130              	# hello_rsa.c:30:     *(addr_rsa+96) = 0;
  30:hello_rsa.c   ****     
 131              		.loc 1 30 0
 132              		addi	a5,a5,248	#, ivtmp.82, tmp141
 133              	.LVL5:
 134              	.L8:
 135              	.LBB13:
 136              	# hello_rsa.c:34:         *(addr_rsa+i) = 0;
  34:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 137              		.loc 1 34 0 discriminator 3
 138              		sd	zero,0(a5)	#, *_3
 139              		addi	a5,a5,-8	#, ivtmp.82, ivtmp.82
 140              	# hello_rsa.c:33:     for (int i = 31; i >= 1; i--) {
  33:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 141              		.loc 1 33 0 discriminator 3
 142              		bne	a5,a4,.L8	#, ivtmp.82, tmp142,
 143              	.LBE13:
 144              	# hello_rsa.c:36:     *(addr_rsa+0) = 8;
  35:hello_rsa.c   ****     }
  36:hello_rsa.c   ****     *(addr_rsa+0) = 8;
 145              		.loc 1 36 0
 146              		li	a3,8	# tmp144,
 147              	.LBB14:
 148              	# hello_rsa.c:39:     for (int i = 63; i >= 33; i--) {
  37:hello_rsa.c   **** 
  38:hello_rsa.c   ****     // exponent = 13
  39:hello_rsa.c   ****     for (int i = 63; i >= 33; i--) {
 149              		.loc 1 39 0
 150              		li	a4,1342177280	# tmp146,
 151              	.LBE14:
 152              	# hello_rsa.c:36:     *(addr_rsa+0) = 8;
  36:hello_rsa.c   **** 
 153              		.loc 1 36 0
 154              		sd	a3,0(a5)	# tmp144, MEM[(volatile long long unsigned int *)1342177280B]
 155              	.LVL6:
 156              		addi	a5,a5,504	#, ivtmp.75, ivtmp.82
 157              	.LBB15:
 158              	# hello_rsa.c:39:     for (int i = 63; i >= 33; i--) {
 159              		.loc 1 39 0
 160              		addi	a3,a4,256	#, tmp145, tmp146
 161              	.LVL7:
 162              	.L9:
 163              	# hello_rsa.c:40:         *(addr_rsa+i) = 0;
  40:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 164              		.loc 1 40 0 discriminator 3
 165              		sd	zero,0(a5)	#, *_6
 166              		addi	a5,a5,-8	#, ivtmp.75, ivtmp.75
 167              	# hello_rsa.c:39:     for (int i = 63; i >= 33; i--) {
  39:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 168              		.loc 1 39 0 discriminator 3
 169              		bne	a5,a3,.L9	#, ivtmp.75, tmp145,
 170              	.LBE15:
 171              	.LBB16:
 172              	# hello_rsa.c:45:     for (int i = 95; i >= 65; i--) {
  41:hello_rsa.c   ****     }
  42:hello_rsa.c   ****     *(addr_rsa+32) = 13;
  43:hello_rsa.c   **** 
  44:hello_rsa.c   ****     // modulus = 77
  45:hello_rsa.c   ****     for (int i = 95; i >= 65; i--) {
 173              		.loc 1 45 0
 174              		li	a3,1342177280	# tmp151,
 175              	.LBE16:
 176              	# hello_rsa.c:42:     *(addr_rsa+32) = 13;
  42:hello_rsa.c   **** 
 177              		.loc 1 42 0
 178              		li	a2,13	# tmp149,
 179              		sd	a2,0(a5)	# tmp149, MEM[(volatile long long unsigned int *)1342177536B]
 180              	.LVL8:
 181              		addi	a5,a4,760	#, ivtmp.66, tmp146
 182              	.LBB17:
 183              	# hello_rsa.c:45:     for (int i = 95; i >= 65; i--) {
 184              		.loc 1 45 0
 185              		addi	a4,a3,512	#, tmp150, tmp151
 186              	.LVL9:
 187              	.L10:
 188              	# hello_rsa.c:46:         *(addr_rsa+i) = 0;
  46:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 189              		.loc 1 46 0 discriminator 3
 190              		sd	zero,0(a5)	#, *_9
 191              		addi	a5,a5,-8	#, ivtmp.66, ivtmp.66
 192              	# hello_rsa.c:45:     for (int i = 95; i >= 65; i--) {
  45:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 193              		.loc 1 45 0 discriminator 3
 194              		bne	a5,a4,.L10	#, ivtmp.66, tmp150,
 195              	.LBE17:
 196              	# hello_rsa.c:48:     *(addr_rsa+64) = 77;
  47:hello_rsa.c   ****     }
  48:hello_rsa.c   ****     *(addr_rsa+64) = 77;
 197              		.loc 1 48 0
 198              		li	a4,77	# tmp154,
 199              		sd	a4,0(a5)	# tmp154, MEM[(volatile long long unsigned int *)1342177792B]
 200              	# hello_rsa.c:51:     *(addr_rsa+96) = 1;
  49:hello_rsa.c   **** 
  50:hello_rsa.c   ****     // go = 1
  51:hello_rsa.c   ****     *(addr_rsa+96) = 1;
 201              		.loc 1 51 0
 202              		li	a5,1	# tmp157,
 203              		sd	a5,768(a3)	# tmp157, MEM[(volatile long long unsigned int *)1342178048B]
 204              	# hello_rsa.c:55:         data = *(addr_rsa+129);
  52:hello_rsa.c   **** 
  53:hello_rsa.c   ****     // check done = 1
  54:hello_rsa.c   ****     do {
  55:hello_rsa.c   ****         data = *(addr_rsa+129);
 205              		.loc 1 55 0
 206              		li	a5,1342177280	# tmp158,
 207              	# hello_rsa.c:56:     } while (data != 1);
  56:hello_rsa.c   ****     } while (data != 1);
 208              		.loc 1 56 0
 209              		li	a3,1	# tmp159,
 210              	.L11:
 211              	# hello_rsa.c:55:         data = *(addr_rsa+129);
  55:hello_rsa.c   ****     } while (data != 1);
 212              		.loc 1 55 0 discriminator 1
 213              		ld	a4,1032(a5)	# data, MEM[(volatile long long unsigned int *)1342177280B + 1032B]
 214              	.LVL10:
 215              	# hello_rsa.c:56:     } while (data != 1);
 216              		.loc 1 56 0 discriminator 1
 217              		bne	a4,a3,.L11	#, data, tmp159,
 218              	.LBB18:
 219              	.LBB19:
 220              	# hello_rsa.c:7:    for (i=0; i<n; i++)
   7:hello_rsa.c   ****       dest_char[i] = src_char[i]; //copy contents byte by byte
 221              		.loc 1 7 0
 222              		li	a0,1342177280	# tmp163,
 223              	.LVL11:
 224              	.LBE19:
 225              	.LBE18:
 226              		addi	a5,a5,776	#, ivtmp.57, tmp158
 227              	.LBB21:
 228              	.LBB20:
 229              	# hello_rsa.c:8:       dest_char[i] = src_char[i]; //copy contents byte by byte
   8:hello_rsa.c   **** }
 230              		.loc 1 8 0
 231              		li	a1,1073741824	# tmp160,
 232              	.LVL12:
 233              	# hello_rsa.c:7:    for (i=0; i<n; i++)
   7:hello_rsa.c   ****       dest_char[i] = src_char[i]; //copy contents byte by byte
 234              		.loc 1 7 0
 235              		addi	a2,a0,1032	#, tmp162, tmp163
 236              	.LVL13:
 237              	.L12:
 238              	# hello_rsa.c:8:       dest_char[i] = src_char[i]; //copy contents byte by byte
   8:hello_rsa.c   **** }
 239              		.loc 1 8 0
 240              		lbu	a3,0(a5)	# _64, *_62
 241              		add	a4,a1,a5	# ivtmp.57, tmp161, tmp160
 242              		addi	a5,a5,1	#, ivtmp.57, ivtmp.57
 243              	.LVL14:
 244              		sb	a3,-776(a4)	# _64, MEM[(char *)_86]
 245              	# hello_rsa.c:7:    for (i=0; i<n; i++)
   7:hello_rsa.c   ****       dest_char[i] = src_char[i]; //copy contents byte by byte
 246              		.loc 1 7 0
 247              		bne	a5,a2,.L12	#, ivtmp.57, tmp162,
 248              	.LBE20:
 249              	.LBE21:
 250              	# hello_rsa.c:68:     *(addr_rsa+96) = 0;
  57:hello_rsa.c   **** 
  58:hello_rsa.c   ****     // read output
  59:hello_rsa.c   ****     //for (int i = 97; i <= 128; i++) {
  60:hello_rsa.c   ****     //    data = *(addr_rsa+i);
  61:hello_rsa.c   ****     //}
  62:hello_rsa.c   ****     custom_memcpy(addr_dram, (addr_rsa+97), 256);
  63:hello_rsa.c   ****     // Test 1 complete
  64:hello_rsa.c   ****     
  65:hello_rsa.c   **** 
  66:hello_rsa.c   ****     // Test 2
  67:hello_rsa.c   ****     // go = 0
  68:hello_rsa.c   ****     *(addr_rsa+96) = 0;
 251              		.loc 1 68 0
 252              		li	a5,9	# tmp136,
 253              		slli	a5,a5,28	#, ivtmp.49, tmp136
 254              		sd	zero,768(a0)	#, MEM[(volatile long long unsigned int *)1342178048B]
 255              	.LVL15:
 256              	.LBB22:
 257              	.LBB23:
 258              	# hello_rsa.c:17:       dest_char[j] = src_char[j]; //copy contents byte by byte
  17:hello_rsa.c   **** }
 259              		.loc 1 17 0
 260              		li	a1,-1073741824	# tmp166,
 261              	# hello_rsa.c:16:    for (j=0; j<n; j++)
  16:hello_rsa.c   ****       dest_char[j] = src_char[j]; //copy contents byte by byte
 262              		.loc 1 16 0
 263              		addi	a2,a5,256	#, tmp168, ivtmp.49
 264              	.LVL16:
 265              	.L13:
 266              	# hello_rsa.c:17:       dest_char[j] = src_char[j]; //copy contents byte by byte
  17:hello_rsa.c   **** }
 267              		.loc 1 17 0
 268              		lbu	a3,0(a5)	# _58, *_56
 269              		add	a4,a1,a5	# ivtmp.49, tmp167, tmp166
 270              		addi	a5,a5,1	#, ivtmp.49, ivtmp.49
 271              	.LVL17:
 272              		sb	a3,0(a4)	# _58, MEM[(char *)_108]
 273              	# hello_rsa.c:16:    for (j=0; j<n; j++)
  16:hello_rsa.c   ****       dest_char[j] = src_char[j]; //copy contents byte by byte
 274              		.loc 1 16 0
 275              		bne	a5,a2,.L13	#, ivtmp.49, tmp168,
 276              	.LBE23:
 277              	.LBE22:
 278              	.LBB25:
 279              	# hello_rsa.c:78:     for (int i = 63; i >= 33; i--) {
  69:hello_rsa.c   ****     
  70:hello_rsa.c   ****     // message <= cipher = 50
  71:hello_rsa.c   ****     //for (int i = 1; i <= 31; i++) {
  72:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
  73:hello_rsa.c   ****     //}
  74:hello_rsa.c   ****     //*(addr_rsa+0) = 50;
  75:hello_rsa.c   ****     custom_memcpy_2(addr_rsa, addr_dram, 256);
  76:hello_rsa.c   **** 
  77:hello_rsa.c   ****     // exponent = 37
  78:hello_rsa.c   ****     for (int i = 63; i >= 33; i--) {
 280              		.loc 1 78 0
 281              		li	a5,1342177280	# tmp172,
 282              	.LBE25:
 283              	.LBB26:
 284              	.LBB24:
 285              	# hello_rsa.c:16:    for (j=0; j<n; j++)
  16:hello_rsa.c   ****       dest_char[j] = src_char[j]; //copy contents byte by byte
 286              		.loc 1 16 0
 287              		li	a4,1342177280	# tmp137,
 288              		addi	a4,a4,504	#, ivtmp.41, tmp137
 289              	.LBE24:
 290              	.LBE26:
 291              	.LBB27:
 292              	# hello_rsa.c:78:     for (int i = 63; i >= 33; i--) {
 293              		.loc 1 78 0
 294              		addi	a3,a5,256	#, tmp171, tmp172
 295              	.L14:
 296              	# hello_rsa.c:79:         *(addr_rsa+i) = 0;
  79:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 297              		.loc 1 79 0 discriminator 3
 298              		sd	zero,0(a4)	#, *_12
 299              	.LVL18:
 300              		addi	a4,a4,-8	#, ivtmp.41, ivtmp.41
 301              	# hello_rsa.c:78:     for (int i = 63; i >= 33; i--) {
  78:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 302              		.loc 1 78 0 discriminator 3
 303              		bne	a4,a3,.L14	#, ivtmp.41, tmp171,
 304              	.LBE27:
 305              	.LBB28:
 306              	# hello_rsa.c:84:     for (int i = 95; i >= 65; i--) {
  80:hello_rsa.c   ****     }
  81:hello_rsa.c   ****     *(addr_rsa+32) = 37;
  82:hello_rsa.c   **** 
  83:hello_rsa.c   ****     // modulus = 77
  84:hello_rsa.c   ****     for (int i = 95; i >= 65; i--) {
 307              		.loc 1 84 0
 308              		li	a3,1342177280	# tmp177,
 309              	.LBE28:
 310              	# hello_rsa.c:81:     *(addr_rsa+32) = 37;
  81:hello_rsa.c   **** 
 311              		.loc 1 81 0
 312              		li	a2,37	# tmp175,
 313              		sd	a2,0(a4)	# tmp175, MEM[(volatile long long unsigned int *)1342177536B]
 314              	.LVL19:
 315              		addi	a5,a5,760	#, ivtmp.32, tmp172
 316              	.LBB29:
 317              	# hello_rsa.c:84:     for (int i = 95; i >= 65; i--) {
 318              		.loc 1 84 0
 319              		addi	a4,a3,512	#, tmp176, tmp177
 320              	.LVL20:
 321              	.L15:
 322              	# hello_rsa.c:85:         *(addr_rsa+i) = 0;
  85:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 323              		.loc 1 85 0 discriminator 3
 324              		sd	zero,0(a5)	#, *_15
 325              		addi	a5,a5,-8	#, ivtmp.32, ivtmp.32
 326              	# hello_rsa.c:84:     for (int i = 95; i >= 65; i--) {
  84:hello_rsa.c   ****         *(addr_rsa+i) = 0;
 327              		.loc 1 84 0 discriminator 3
 328              		bne	a5,a4,.L15	#, ivtmp.32, tmp176,
 329              	.LBE29:
 330              	# hello_rsa.c:87:     *(addr_rsa+64) = 77;
  86:hello_rsa.c   ****     }
  87:hello_rsa.c   ****     *(addr_rsa+64) = 77;
 331              		.loc 1 87 0
 332              		li	a4,77	# tmp180,
 333              		sd	a4,0(a5)	# tmp180, MEM[(volatile long long unsigned int *)1342177792B]
 334              	# hello_rsa.c:90:     *(addr_rsa+96) = 1;
  88:hello_rsa.c   **** 
  89:hello_rsa.c   ****     // go = 1
  90:hello_rsa.c   ****     *(addr_rsa+96) = 1;
 335              		.loc 1 90 0
 336              		li	a5,1	# tmp183,
 337              		sd	a5,768(a3)	# tmp183, MEM[(volatile long long unsigned int *)1342178048B]
 338              	# hello_rsa.c:94:         data = *(addr_rsa+129);
  91:hello_rsa.c   **** 
  92:hello_rsa.c   ****     // check done = 1
  93:hello_rsa.c   ****     do {
  94:hello_rsa.c   ****         data = *(addr_rsa+129);
 339              		.loc 1 94 0
 340              		li	a5,1342177280	# tmp184,
 341              	# hello_rsa.c:95:     } while (data != 1);
  95:hello_rsa.c   ****     } while (data != 1);
 342              		.loc 1 95 0
 343              		li	a3,1	# tmp185,
 344              	.L16:
 345              	# hello_rsa.c:94:         data = *(addr_rsa+129);
  94:hello_rsa.c   ****     } while (data != 1);
 346              		.loc 1 94 0 discriminator 1
 347              		ld	a4,1032(a5)	# data, MEM[(volatile long long unsigned int *)1342177280B + 1032B]
 348              	.LVL21:
 349              	# hello_rsa.c:95:     } while (data != 1);
 350              		.loc 1 95 0 discriminator 1
 351              		bne	a4,a3,.L16	#, data, tmp185,
 352              	.LBB30:
 353              	# hello_rsa.c:98:     for (int i = 128; i >= 97; i--) {
  96:hello_rsa.c   **** 
  97:hello_rsa.c   ****     // read output
  98:hello_rsa.c   ****     for (int i = 128; i >= 97; i--) {
 354              		.loc 1 98 0
 355              		li	a4,1342177280	# tmp187,
 356              	.LVL22:
 357              	.LBE30:
 358              		addi	a5,a5,1024	#, ivtmp.23, tmp184
 359              	.LBB31:
 360              		addi	a4,a4,768	#, tmp186, tmp187
 361              	.L17:
 362              	# hello_rsa.c:99:         data = *(addr_rsa+i);
  99:hello_rsa.c   ****         data = *(addr_rsa+i);
 363              		.loc 1 99 0 discriminator 3
 364              		ld	a3,0(a5)	# data, *_18
 365              	.LVL23:
 366              		addi	a5,a5,-8	#, ivtmp.23, ivtmp.23
 367              	# hello_rsa.c:98:     for (int i = 128; i >= 97; i--) {
  98:hello_rsa.c   ****         data = *(addr_rsa+i);
 368              		.loc 1 98 0 discriminator 3
 369              		bne	a5,a4,.L17	#, ivtmp.23, tmp186,
 370              	.LBE31:
 371              	# hello_rsa.c:197: }
 100:hello_rsa.c   ****     }
 101:hello_rsa.c   ****     // Test 2 complete
 102:hello_rsa.c   **** 
 103:hello_rsa.c   **** 
 104:hello_rsa.c   ****     //// Test 3
 105:hello_rsa.c   ****     //// go = 0
 106:hello_rsa.c   ****     //*(addr_rsa+96) = 0;
 107:hello_rsa.c   ****     //
 108:hello_rsa.c   ****     //// message = 25
 109:hello_rsa.c   ****     //for (int i = 1; i <= 31; i++) {
 110:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
 111:hello_rsa.c   ****     //}
 112:hello_rsa.c   ****     //*(addr_rsa+0) = 25;
 113:hello_rsa.c   **** 
 114:hello_rsa.c   ****     //// exponent = 7
 115:hello_rsa.c   ****     //for (int i = 63; i >= 33; i--) {
 116:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
 117:hello_rsa.c   ****     //}
 118:hello_rsa.c   ****     //*(addr_rsa+32) = 7;
 119:hello_rsa.c   **** 
 120:hello_rsa.c   ****     //// modulus = 143
 121:hello_rsa.c   ****     //for (int i = 95; i >= 65; i--) {
 122:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
 123:hello_rsa.c   ****     //}
 124:hello_rsa.c   ****     //*(addr_rsa+64) = 143;
 125:hello_rsa.c   **** 
 126:hello_rsa.c   ****     //// go = 1
 127:hello_rsa.c   ****     //*(addr_rsa+96) = 1;
 128:hello_rsa.c   **** 
 129:hello_rsa.c   ****     //// check done = 1
 130:hello_rsa.c   ****     //do {
 131:hello_rsa.c   ****     //    data = *(addr_rsa+129);
 132:hello_rsa.c   ****     //} while (data != 1);
 133:hello_rsa.c   **** 
 134:hello_rsa.c   ****     //// read output
 135:hello_rsa.c   ****     //for (int i = 128; i >= 97; i--) {
 136:hello_rsa.c   ****     //    data = *(addr_rsa+i);
 137:hello_rsa.c   ****     //}
 138:hello_rsa.c   ****     //// Test 3 complete
 139:hello_rsa.c   **** 
 140:hello_rsa.c   **** 
 141:hello_rsa.c   ****     //// Test 4
 142:hello_rsa.c   ****     //// go = 0
 143:hello_rsa.c   ****     //*(addr_rsa+96) = 0;
 144:hello_rsa.c   ****     //
 145:hello_rsa.c   ****     //// message <= cipher = 64
 146:hello_rsa.c   ****     //for (int i = 1; i <= 31; i++) {
 147:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
 148:hello_rsa.c   ****     //}
 149:hello_rsa.c   ****     //*(addr_rsa+0) = 64;
 150:hello_rsa.c   **** 
 151:hello_rsa.c   ****     //// exponent = 103
 152:hello_rsa.c   ****     //for (int i = 63; i >= 33; i--) {
 153:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
 154:hello_rsa.c   ****     //}
 155:hello_rsa.c   ****     //*(addr_rsa+32) = 103;
 156:hello_rsa.c   **** 
 157:hello_rsa.c   ****     //// modulus = 143
 158:hello_rsa.c   ****     //for (int i = 95; i >= 65; i--) {
 159:hello_rsa.c   ****     //    *(addr_rsa+i) = 0;
 160:hello_rsa.c   ****     //}
 161:hello_rsa.c   ****     //*(addr_rsa+64) = 143;
 162:hello_rsa.c   **** 
 163:hello_rsa.c   ****     //// go = 1
 164:hello_rsa.c   ****     //*(addr_rsa+96) = 1;
 165:hello_rsa.c   **** 
 166:hello_rsa.c   ****     //// check done = 1
 167:hello_rsa.c   ****     //do {
 168:hello_rsa.c   ****     //    data = *(addr_rsa+129);
 169:hello_rsa.c   ****     //} while (data != 1);
 170:hello_rsa.c   **** 
 171:hello_rsa.c   ****     //// read output
 172:hello_rsa.c   ****     //for (int i = 128; i >= 97; i--) {
 173:hello_rsa.c   ****     //    data = *(addr_rsa+i);
 174:hello_rsa.c   ****     //}
 175:hello_rsa.c   ****     //// Test 4 complete
 176:hello_rsa.c   **** 
 177:hello_rsa.c   **** 
 178:hello_rsa.c   **** 
 179:hello_rsa.c   **** 
 180:hello_rsa.c   **** 
 181:hello_rsa.c   ****     //*addr_rsa = 0x123456789ABCDEF1;
 182:hello_rsa.c   **** 
 183:hello_rsa.c   ****     //data = *addr_rsa;
 184:hello_rsa.c   **** 
 185:hello_rsa.c   ****     //if (data == 0x123456789ABCDEF1) {
 186:hello_rsa.c   ****     //    *(addr_rsa+1) = 0x1FEDCBA987654321;
 187:hello_rsa.c   ****     //    *(addr_rsa+2) = 0x1FEDCBA9876543;
 188:hello_rsa.c   ****     //    *(addr_rsa+3) = 0x1FEDCBA98765;
 189:hello_rsa.c   ****     //    *(addr_rsa+4) = 0x1FEDCBA987;
 190:hello_rsa.c   ****     //    *(addr_rsa+5) = 0x1FEDCBA9;
 191:hello_rsa.c   ****     //    *(addr_rsa+6) = 0x1FEDCB;
 192:hello_rsa.c   ****     //    *(addr_rsa+7) = 0x1FED;
 193:hello_rsa.c   ****     //    *(addr_rsa+8) = 0x1F;
 194:hello_rsa.c   ****     //}
 195:hello_rsa.c   **** 
 196:hello_rsa.c   ****     return 0;
 197:hello_rsa.c   **** }
 372              		.loc 1 197 0
 373              		li	a0,0	#,
 374 ???? C3       		ret
 375              		.cfi_endproc
 376              	.LFE2:
 378              		.text
 379              	.Letext0:
